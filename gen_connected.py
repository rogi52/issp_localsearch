#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import os
import numpy as np
import copy
import math
import click

from pymoo.factory import get_visualization, get_reference_directions
from pymoo.util.ref_dirs.energy import RieszEnergyReferenceDirectionFactory

# This function is from Platypus: https://github.com/Project-Platypus/Platypus/blob/master/platypus/weights.py
def normal_boundary_weights(nobjs, divisions_outer, divisions_inner=0):
    """Returns weights generated by the normal boundary method.
    
    The weights produced by this method are uniformly distributed on the
    hyperplane intersecting
    
        [(1, 0, ..., 0), (0, 1, ..., 0), ..., (0, 0, ..., 1)].
        
    Parameters
    ----------
    nobjs : int
        The number of objectives.
    divisions_outer : int
        The number of divisions along the outer set of weights.
    divisions_inner : int (optional)
        The number of divisions along the inner set of weights.
    """
    
    def generate_recursive(weights, weight, left, total, index):
        if index == nobjs - 1:
            weight[index] = float(left) / float(total)
            weights.append(copy.copy(weight))
        else:
            for i in range(left+1):
                weight[index] = float(i) / float(total)
                generate_recursive(weights, weight, left-i, total, index+1)
    
    def generate_weights(divisions):
        weights = []
        generate_recursive(weights, [0.0]*nobjs, divisions, divisions, 0)
        return weights
        
    weights = generate_weights(divisions_outer)
    
    if divisions_inner > 0:
        inner_weights = generate_weights(divisions_inner)
        
        for i in range(len(inner_weights)):
            weight = inner_weights[i]
            
            for j in range(len(weight)):
                weight[j] = (1.0 / nobjs + weight[j]) / 2.0
                
            weights.append(weight)
        
    return weights

def w_numbers(n_obj, n_div):
    """Return the number of weight vectors generated by the simplex lattice design based on a given number of divisions.

    :param n_obj: int: The number of objectives
    :param n_div: int: The number of divisions

    :return  The number of resulting weight vectors
    """    
    tmp1 = n_div + n_obj - 1
    tmp2 = n_obj - 1
    return int(math.factorial(tmp1) / (math.factorial(tmp2) * math.factorial(tmp1 - tmp2)))

def nums_division_weights(n_obj=2, max_n_div=100):
    """Return (1) the number of divisions and (2) the number of weight vectors generated by the simplex lattice design. Note that this function does not generate actual weight vectors.

    :param n_obj: int: The number of objectives
    :param max_n_div: int: The maximum number of divisions. 

    :return Two ndarrays of the numbers of divisions and the numbers of weight vectors.
    """
    n_divs = np.arange(1, max_n_div+1)
    n_weights = []
    for n_div in n_divs:
        nw = w_numbers(n_obj, n_div)
        n_weights.append(nw)
        print(n_div, nw)
        
    return n_divs, np.array(n_weights)
        
def create_w_points():
    """ Generate a set of weight vectors by the simplex lattice design (or the two-layered simplex lattice design).
    """
    weight_point_dir_path = './weight_point_dataset'
    os.makedirs(weight_point_dir_path, exist_ok=True)    

    # I set these numbers of divisions so that the resulting number of weight vectors becomes either of approximately 100, 500, 1000, 5000, and 10000.    
    #for n_obj in [2, 3, 4, 5, 6]:
    for n_obj in [2]:        
        if n_obj == 2:
            #n_divs = [9, 49, 99, 999, 1999, 3999, 7999, 15999]
            n_divs = [9, 49, 99, 999, 1999, 3999, 5999, 7999, 9999]                        
        elif n_obj == 3:
            # n_weits = 105, 990, 2016, 4005, 8001, 15931
            n_divs = [13, 43, 62, 88, 125, 177]
        elif n_obj == 4:
            # n_weits = 969, 2024, 4060, 7770, 16215
            n_divs = [16, 21, 27, 34, 44]
        elif n_obj == 5:
            # n_weits = 1001, 1820, 3876, 7315, 14950
            n_divs = [10, 12, 15, 18, 22]
        elif n_obj == 6:
            # n_weits = 1001, 1820, 3876, 7315, 14950
            n_divs = [7, 9, 11, 13, 15]
    
        for n_div in n_divs:
            n_ref_points = w_numbers(n_obj, n_div)        
            w_set = np.array(normal_boundary_weights(nobjs=n_obj, divisions_outer=n_div, divisions_inner=0))
            weight_point_file_path = os.path.join(weight_point_dir_path, 'd{}_n{}.csv'.format(n_obj, n_ref_points))
            np.savetxt(weight_point_file_path, w_set, delimiter=',')

@click.command()
@click.option('--n_obj', '-no', required=True, default=2, type=int, help='The number of objectives.')
@click.option('--n_weight', '-nw', required=True, default=10, type=int, help='The number of weight vectors.')
def create_w_pymoo(n_obj, n_weight):    
    """ Generate a set of weight vectors by an iterative improvement method that tries to minimize the s-energy value. For details, see the following refrence. The implementation of pymoo is used.

    Julian Blank, Kalyanmoy Deb, Yashesh D. Dhebar, Sunith Bandaru, Haitham Seada: Generating Well-Spaced Points on a Unit Simplex for Evolutionary Many-Objective Optimization. IEEE Trans. Evol. Comput. 25(1): 48-60 (2021)

    :param n_obj: int: The number of objectives
    :param n_weight: int: The number of weight vectors

    """
    weight_point_dir_path = './weight_point_dataset'
    os.makedirs(weight_point_dir_path, exist_ok=True)    
    weight_point_file_path = os.path.join(weight_point_dir_path, 'd{}_n{}.csv'.format(n_obj, n_weight))

    points = get_reference_directions("energy", n_obj, n_weight, seed=1)
    np.savetxt(weight_point_file_path, points, delimiter=',')

def regular_pareto_front(pf_shape='linear', n_obj=2, n_ref_points=1000):
    """ Generate a set of reference points by translating a set of weight vectors. Thus, the corresponding set of weight vectors should be generated a priori. For details, see the following reference:

    Y. Tian, X. Xiang, X. Zhang, R. Cheng, and Y. Jin, "Sampling Reference Points on the Pareto Fronts of Benchmark Multi-Objective Optimization Problems," in IEEE CEC, 2018, pp. 1â€“6

    :param pf_shape: str: A shape of the Pareto front
    :param n_obj: int: The number of objectives
    :param n_ref_points: int: The number of reference points. This should be the same as the number of weight vectors.
    """
    weight_point_file_path = './weight_point_dataset/d{}_n{}.csv'.format(n_obj, n_ref_points)    
    weight_point_set = np.loadtxt(weight_point_file_path, delimiter=',')

    ref_point_dir_path = './ref_point_dataset'
    os.makedirs(ref_point_dir_path, exist_ok=True)    
    ref_point_file_path = os.path.join(ref_point_dir_path, '{}_d{}_n{}.csv'.format(pf_shape, n_obj, n_ref_points))    
    fh = open(ref_point_file_path, 'w')
    
    for w_point in weight_point_set:
        if pf_shape == 'linear':
            ref_point = w_point
        elif pf_shape == 'inverted-linear':
            ref_point = 1 - w_point
        elif pf_shape == 'nonconvex':        
            trans_value = np.sqrt(np.sum(np.square(w_point)))
            ref_point = w_point / trans_value
        elif pf_shape == 'inverted-nonconvex':
            trans_value = np.sqrt(np.sum(np.square(w_point)))            
            ref_point = 1 - (w_point / trans_value)
        elif pf_shape == 'convex':        
            trans_value1 = (np.sum(np.sqrt(w_point[:-1])))**2
            trans_value2 = (trans_value1 + 2 * w_point[-1] + np.sqrt(trans_value1**2 + 4 * trans_value1 * w_point[-1])) / 2.0
            ref_point = w_point / trans_value2
        elif pf_shape == 'inverted-convex':        
            trans_value1 = (np.sum(np.sqrt(w_point[:-1])))**2
            trans_value2 = (trans_value1 + 2 * w_point[-1] + np.sqrt(trans_value1**2 + 4 * trans_value1 * w_point[-1])) / 2.0
            ref_point = 1 - (w_point / trans_value2)

        str_ref_point = [str(x) for x in ref_point]
        res = ','.join(str_ref_point) + '\n'
        fh.write(res) 
    fh.close()    

def create_ref_points():
    for n_obj in [2, 3, 4, 5, 6]:
        for pf_shape in ['linear', 'nonconvex', 'convex', 'inverted-linear', 'inverted-nonconvex', 'inverted-convex']:
            for n_ref_points in [1000, 2000, 4000, 6000, 8000, 10000]:
                regular_pareto_front(pf_shape, n_obj, n_ref_points)                

    n_obj = 2        
    for pf_shape in ['linear', 'nonconvex', 'convex', 'inverted-linear', 'inverted-nonconvex', 'inverted-convex']:
        for n_ref_points in [10, 50, 100]:
            regular_pareto_front(pf_shape, n_obj, n_ref_points)  

def demo():
    regular_pareto_front(pf_shape = 'linear', n_obj = 2, n_ref_points = 1000)


@click.command()
@click.option('--mode')
def main(mode):
    if mode == 'demo':
        create_w_points()
        demo()
    else:
        create_w_points()
        create_w_pymoo()
        create_ref_points()


if __name__ == '__main__':
    main()
